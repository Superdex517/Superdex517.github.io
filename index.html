<CPU 구조도>             <----------------------------->        - <입출력 버스 (I/O Bus)>            <----------------------> 개인 메모리(Main Memory)
ALU / 컨트롤 유닛 / 버스 인터페이스 / 레지스터 set                 키보드 / 모니터 / 네트웍 카드 / 하드 디스크
  *레지스터 set은 임시 저장소를 말한다
*입출력장치 통신 구조도 하나 추가
  
<힙/데이터 영역, 스택의 설명과 구조도>
  
<소켓>
  - 컴퓨터가 서로 통신하기 위한 도구
  - 소켓은 모든 운영체제에서 지원해주는 것이다.
  - 패킷이랑 소켓이 주고 받는 데이터를 정형화 해놓은 것
  - 소켓의 구성요소
    1. 인터넷 프로토콜(UDP, TCP, rowIP...)
    2. 로컬 IP주소
    3. 로컬 포터
    4. 원격 IP주소
    5. 원격 포트
  - 소켓은 연결지향형, 비연결 지향형이 있다.
    1. 연결지향형
       : 서로 연결된 상태(TCP가 해당)
         데이터가 소실되면 안될때 사용
         대다수가 TCP
    2. 비연결 지향형
        : UDP가 대표적
          상대가 다 수신했는지 확인 불가능
          속도 빠름, 데이터 소실 가능성 큼
          동영상 스트리밍 서비스(but 넷플릭스는 TCP 사용)
  
  *서버와 클라이언트 통신 구조도 하나 추가

  <TCP 소켓의 두가지>
    - 다른 컴퓨터로부터 들어오는 접속 승인 요청을 수락해주는 소켓
    - 다른 컴퓨터와 연결된 소켓
    
    IP주소 1. IPv4 -> 32bit
           2. IPv6 -> 16byte
    
<서버구현 스토리라인>
  - 쓰레드를 생성한다
    : 쓰레드가 동작할때 메모리에 데이터가 올라가는 순서에서 문제가 생긴다.
      두개의 쓰레드를 만들고 하나의 전역 변수를 건들게 되면 서루 경합을 하게 된다.
      이때 문제점은 순서가 보장되지 않아 데이터가 뒤죽박죽이 될 수 있다.
  - 해결 방법
    : Atomic(Altor-Nothing) : 생각보다 느림, 정말 필요한 곳에서만 사용하는게 좋음(병목현상 발생)
      Lock 구현 - Mutua Exclusive (Mutex) : 재귀적으로 Lock을 호출할 수 없음
          - DeadLock: 멀티쓰레드 내에서 경합이 안맞았거나, 서로 반쪽짜리 락을 잡았거나
      Lock 구현 이론:  1. 무작정 기다린다. (유저 레벨에서 무한루프에 걸릴수도 있다 (존버))
                      2. 일단 자리로 돌아갔다가 나중에 다시 와서 락을 잡는다. (랜덤)
                      3. 직원에게 부탁(갑질)

  
-데이터를 저장하는 메모리 블록을 커널 오브젝트라고 함

<condition variable>

<캐시철학>
  1. Temporal Locality
  2. Spatial Locality  
  * 캐시메모리/ 레지스터 <-------------> 메인 메모리 RAM      구조도추가
  
<>
  여러 쓰레드가 동일한 메모리에 동시 접근, 그 중 하나는 write 연산
  Race Condition(경합 조건)이 일어난다.
  Undefinded Behavior(정의되지 않은 행동)
    - Lock(mutex)를 이용한 상호 배타적 (Mutual Exclusive)접근
    - Atomic(원자적) 연산을 이용
  Atomic의 메모리 모델
  
  <프로세스 메모리 구조>
  - 크게 code, Data, BSS, Heap, Stack의 영역으로 나뉜다
  TLS -> Thread Local Storage
  *Thread 메모리 구조도 추가
<스마트 포인터> 
  -Reference Counting(포인터를 막 쓰면 안된다)
  -Shared_Ptr / Weak_Ptr

 
 <소켓옵션> c++ 문서 확인
  
  <블로킹/논블로킹 소켓>
   -블로킹 소켓: (프로세스 대기를 타는 부분이 문제가 될 수 있음, 쓰레드 컨텍스트 스위칭이 문제가 될 것임)
    accept -> 접속한 클라가 있을 때
    connect -> 서버 접속 성공했을 때
    send, sendto -> 요청한 데이터를 송신 버퍼에 복사했을 때
    recv, recvfrom -> 수신 버퍼에 도착한 데이터가 있고, 이를 유저레벨 버퍼에 복사했을 때
   
   -논블로킹 소켓: 다양한 소켓 모델들이 존재
   
   -Select
   -WSAEventSelect
   -Overlapped(이벤트 기반)
   -OverLapped(콜백 기반)
   -Completion Port
   
